package HorarioDeTrabalho;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.json.JSONArray;
import org.json.JSONObject;


public class CalculoServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		// Obter os horários de trabalho e marcações do banco de dados ou sessão
		String horariosJson = request.getParameter("horarios");
		String marcacoesJson = request.getParameter("marcacoes");
		if (horariosJson == null || marcacoesJson == null) {
			throw new IllegalArgumentException("Horários ou marcações não fornecidos.");
		}

		JSONArray horariosArray = new JSONArray(horariosJson);
		JSONArray marcacoesArray = new JSONArray(marcacoesJson);
		List<Intervalo> horariosDeTrabalho = new ArrayList<>();
		for (int i = 0; i < horariosArray.length(); i++) {
			JSONObject obj = horariosArray.getJSONObject(i);
			horariosDeTrabalho.add(new Intervalo(obj.getString("entrada"), obj.getString("saida")));
		}
		List<Intervalo> marcacoesFeitas = new ArrayList<>();
		for (int i = 0; i < marcacoesArray.length(); i++) {
			JSONObject obj = marcacoesArray.getJSONObject(i);
			marcacoesFeitas.add(new Intervalo(obj.getString("entrada"), obj.getString("saida")));
		}

		List<Intervalo> atrasos = calcularAtrasos(horariosDeTrabalho, marcacoesFeitas);
		List<Intervalo> horasExtras = calcularHorasExtras(horariosDeTrabalho, marcacoesFeitas);

		// Converta os resultados para JSON e envie a resposta
		JSONObject jsonResponse = new JSONObject();
		jsonResponse.put("atrasos", atrasos);
		jsonResponse.put("horasExtras", horasExtras);

		response.setContentType("application/json");
		response.getWriter().write(jsonResponse.toString());
	}

	private List<Intervalo> calcularAtrasos(List<Intervalo> horariosDeTrabalho, List<Intervalo> marcacoesFeitas) {
		List<Intervalo> atrasos = new ArrayList<>();

		for (Intervalo trabalho : horariosDeTrabalho) {
			boolean isCovered = false;
			for (Intervalo marcacao : marcacoesFeitas) {
				if (intervalsOverlap(trabalho, marcacao)) {
					isCovered = true;
					break;
				}
			}
			if (isCovered) {
				atrasos.add(trabalho);
			}
			
		}

		return atrasos;
	}

	private List<Intervalo> calcularHorasExtras(List<Intervalo> horariosDeTrabalho, List<Intervalo> marcacoesFeitas) {
		List<Intervalo> horasExtras = new ArrayList<>();

		for (Intervalo marcacao : marcacoesFeitas) {
			boolean isCovered = false;
			for (Intervalo trabalho : horariosDeTrabalho) {
				if (intervalsOverlap(marcacao, trabalho)) {
					isCovered = true;
					break;
				}
			}
			if (!isCovered) {
				horasExtras.add(marcacao);
			}
		}

		return horasExtras;
	}

	// Métodos auxiliares
	private int convertToMinutes(String time) {
		if (time == null || time.isEmpty()) {
			throw new IllegalArgumentException("O tempo fornecido é inválido: " + time);
		}
		String[] parts = time.split(":");
		if (parts.length != 2) {
			throw new IllegalArgumentException("O formato do tempo é inválido: " + time);
		}
		int hours = Integer.parseInt(parts[0]);
		int minutes = Integer.parseInt(parts[1]);
		return hours * 60 + minutes;
	}

	private boolean intervalsOverlap(Intervalo a, Intervalo b) {
		int aStart = convertToMinutes(a.getInicio());
		int aEnd = convertToMinutes(a.getFim());
		int bStart = convertToMinutes(b.getInicio());
		int bEnd = convertToMinutes(b.getFim());

		return aStart < bEnd && bStart < aEnd;
	}

	// Classe auxiliar Intervalo
	public static class Intervalo {
		private String inicio;
		private String fim;

		public Intervalo(String inicio, String fim) {
			this.inicio = inicio;
			this.fim = fim;
		}

		public String getInicio() {
			return inicio;
		}

		public void setInicio(String inicio) {
			this.inicio = inicio;
		}

		public String getFim() {
			return fim;
		}

		public void setFim(String fim) {
			this.fim = fim;
		}
	}
}
