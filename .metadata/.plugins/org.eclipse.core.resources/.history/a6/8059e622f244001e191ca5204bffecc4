package HorarioDeTrabalho;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.json.JSONArray;
import org.json.JSONObject;


public class CalculoServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		// Obter os horários de trabalho e marcações do banco de dados ou sessão
		String horariosJson = request.getParameter("horarios");
		String marcacoesJson = request.getParameter("marcacoes");
		if (horariosJson == null || marcacoesJson == null) {
			throw new IllegalArgumentException("Horários ou marcações não fornecidos.");
		}

		JSONArray horariosArray = new JSONArray(horariosJson);
		JSONArray marcacoesArray = new JSONArray(marcacoesJson);
		List<Intervalo> horariosDeTrabalho = new ArrayList<>();
		for (int i = 0; i < horariosArray.length(); i++) {
			JSONObject obj = horariosArray.getJSONObject(i);
			horariosDeTrabalho.add(new Intervalo(obj.getString("entrada"), obj.getString("saida")));
		}
		List<Intervalo> marcacoesFeitas = new ArrayList<>();
		for (int i = 0; i < marcacoesArray.length(); i++) {
			JSONObject obj = marcacoesArray.getJSONObject(i);
			marcacoesFeitas.add(new Intervalo(obj.getString("entrada"), obj.getString("saida")));
		}

		List<Intervalo> atrasos = calcularAtrasos(horariosDeTrabalho, marcacoesFeitas);
		List<Intervalo> horasExtras = calcularHorasExtras(horariosDeTrabalho, marcacoesFeitas);

		// Converta os resultados para JSON e envie a resposta
		JSONObject jsonResponse = new JSONObject();
		jsonResponse.put("atrasos", atrasos);
		jsonResponse.put("horasExtras", horasExtras);

		response.setContentType("application/json");
		response.getWriter().write(jsonResponse.toString());
	}

	private List<Intervalo> calcularAtrasos(List<Intervalo> horariosDeTrabalho, List<Intervalo> marcacoesFeitas) {
	    List<Intervalo> atrasos = new ArrayList<>();

	    for (Intervalo trabalho : horariosDeTrabalho) {
	        List<Intervalo> tempAtrasos = new ArrayList<>();
	        tempAtrasos.add(trabalho);

	        for (Intervalo marcacao : marcacoesFeitas) {
	            List<Intervalo> newTempAtrasos = new ArrayList<>();
	            for (Intervalo tempAtraso : tempAtrasos) {
	                newTempAtrasos.addAll(subtractIntervals(tempAtraso, marcacao));
	            }
	            tempAtrasos = newTempAtrasos;
	        }

	        atrasos.addAll(tempAtrasos);
	    }

	    return atrasos;
	}


	private List<Intervalo> calcularHorasExtras(List<Intervalo> horariosDeTrabalho, List<Intervalo> marcacoesFeitas) {
	    List<Intervalo> horasExtras = new ArrayList<>();

	    for (Intervalo marcacao : marcacoesFeitas) {
	        List<Intervalo> tempExtras = new ArrayList<>();
	        tempExtras.add(marcacao);

	        for (Intervalo trabalho : horariosDeTrabalho) {
	            List<Intervalo> newTempExtras = new ArrayList<>();
	            for (Intervalo tempExtra : tempExtras) {
	                newTempExtras.addAll(subtractIntervals(tempExtra, trabalho));
	            }
	            tempExtras = newTempExtras;
	        }

	        horasExtras.addAll(tempExtras);
	    }

	    return horasExtras;
	}
	private List<Intervalo> subtractIntervals(Intervalo a, Intervalo b) {
	    int aStart = convertToMinutes(a.getInicio());
	    int aEnd = convertToMinutes(a.getFim());
	    int bStart = convertToMinutes(b.getInicio());
	    int bEnd = convertToMinutes(b.getFim());

	    List<Intervalo> result = new ArrayList<>();

	    if (aEnd <= bStart || aStart >= bEnd) {
	        // Os intervalos não se sobrepõem
	        result.add(a);
	        return result;
	    }

	    if (aStart < bStart) {
	        result.add(new Intervalo(minutesToTime(aStart), minutesToTime(bStart)));
	    }

	    if (aEnd > bEnd) {
	        result.add(new Intervalo(minutesToTime(bEnd), minutesToTime(aEnd)));
	    }

	    return result;
	}

	private String minutesToTime(int minutes) {
	    int hours = minutes / 60;
	    minutes %= 60;
	    return String.format("%02d:%02d", hours, minutes);
	}




	// Métodos auxiliares
	private int convertToMinutes(String time) {
		if (time == null || time.isEmpty()) {
			throw new IllegalArgumentException("O tempo fornecido é inválido: " + time);
		}
		String[] parts = time.split(":");
		if (parts.length != 2) {
			throw new IllegalArgumentException("O formato do tempo é inválido: " + time);
		}
		int hours = Integer.parseInt(parts[0]);
		int minutes = Integer.parseInt(parts[1]);
		return hours * 60 + minutes;
	}

	private boolean intervalsOverlap(Intervalo a, Intervalo b) {
		int aStart = convertToMinutes(a.getInicio());
		int aEnd = convertToMinutes(a.getFim());
		int bStart = convertToMinutes(b.getInicio());
		int bEnd = convertToMinutes(b.getFim());

		return aStart < bEnd && bStart < aEnd;
	}
	

	// Classe auxiliar Intervalo
	public static class Intervalo {
		private String inicio;
		private String fim;

		public Intervalo(String inicio, String fim) {
			this.inicio = inicio;
			this.fim = fim;
		}

		public String getInicio() {
			return inicio;
		}

		public void setInicio(String inicio) {
			this.inicio = inicio;
		}

		public String getFim() {
			return fim;
		}

		public void setFim(String fim) {
			this.fim = fim;
		}
	}
}
